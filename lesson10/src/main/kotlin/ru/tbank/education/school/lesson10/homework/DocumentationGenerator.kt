package ru.tbank.education.school.lesson10.homework

import kotlin.reflect.full.*
import kotlin.reflect.KClass
import kotlin.reflect.KFunction

object DocumentationGenerator {
    fun generateDoc(obj: Any): String {
        val kClass = obj::class

        val classInternalApi = kClass.findAnnotation<InternalApi>()
        if (classInternalApi != null) {
            return "Документация скрыта (InternalApi)."
        }

        val classDoc = kClass.findAnnotation<DocClass>()
        if (classDoc == null) {
            return "Нет документации для класса."
        }

        val builder = StringBuilder()

        builder.append("=== Документация: ${kClass.simpleName} ===\n")
            .append("Описание: ${classDoc.description}\n")
            .append("Автор: ${classDoc.author}\n")
            .append("Версия: ${classDoc.version}\n")

        val properties = kClass.memberProperties
            .filter { property ->
                val hasInternalApiOnProperty = property.hasAnnotation<InternalApi>()
                val hasInternalApiOnGetter = property.getter.hasAnnotation<InternalApi>()
                val hasInternalApiOnConstructorParam = kClass.primaryConstructor?.parameters
                    ?.firstOrNull { it.name == property.name }
                    ?.hasAnnotation<InternalApi>() == true

                !(hasInternalApiOnProperty ||
                        hasInternalApiOnGetter ||
                        hasInternalApiOnConstructorParam)
            }

        if (properties.isNotEmpty()) {
            builder.append("\n--- Свойства ---\n")
            properties.forEach { property ->
                builder.append("- ${property.name}\n")
                val docProp = property.findAnnotation<DocProperty>()
                if (docProp != null) {
                    builder.append("  Описание: ${docProp.description}\n")
                    if (docProp.example.isNotEmpty()) {
                        builder.append("  Пример: ${docProp.example}\n")
                    }
                }
            }
        }

        val allMethods = kClass.declaredMemberFunctions
        val methods = allMethods.filter { function ->
            !function.hasAnnotation<InternalApi>() &&
                    !isAutoGeneratedMethod(function, kClass)
        }

        if (methods.isNotEmpty()) {
            builder.append("\n--- Методы ---\n")
            methods.forEach { function ->
                val parameters = function.parameters
                    .filter { it.kind != kotlin.reflect.KParameter.Kind.INSTANCE }

                val paramsStr = parameters.joinToString(", ") { param ->
                    "${param.name}: ${param.type}"
                }

                builder.append("- ${function.name}($paramsStr)\n")

                val docMethod = function.findAnnotation<DocMethod>()
                if (docMethod != null) {
                    builder.append("  Описание: ${docMethod.description}\n")
                }

                if (parameters.isNotEmpty()) {
                    builder.append("  Параметры:\n")
                    parameters.forEach { param ->
                        val paramDoc = param.findAnnotation<DocParam>()
                        val description = paramDoc?.description ?: "Нет описания"
                        builder.append("    - ${param.name}: $description\n")
                    }
                }

                if (docMethod != null) {
                    if (docMethod.returns != "No description") {
                        builder.append("  Возвращает: ${docMethod.returns}\n")
                    }
                } else {
                    builder.append("  Возвращает: Нет описания\n")
                }
            }
        }

        return builder.toString().trim()
    }

    private fun isAutoGeneratedMethod(function: KFunction<*>, kClass: KClass<*>): Boolean {
        if (kClass.isData) {
            val autoGenerated = setOf("toString", "equals", "hashCode", "copy")
            val componentRegex = Regex("component\\d+")

            return function.name in autoGenerated || componentRegex.matches(function.name)
        }
        return false
    }
}